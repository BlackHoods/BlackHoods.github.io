<!DOCTYPE html>
<html>
<head>
    <meta name="generator" content="Hugo 0.29-DEV" />

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="My thoughts and rambles">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <link rel="icon" type="image/png" href="/images/favicon.ico">

    
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" sizes="192x192" href="/images/touch/chrome-touch-icon-192x192.png">

    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Material Design Lite">
    <link rel="apple-touch-icon-precomposed" href="apple-touch-icon-precomposed.png">

    
    <meta name="msapplication-TileImage" content="images/touch/ms-touch-icon-144x144-precomposed.png">
    <meta name="msapplication-TileColor" content="#3372DF">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en"/>
    <link rel="stylesheet" href="/css/ionicons.min.css"/>
    <link rel="stylesheet" href="https://storage.googleapis.com/code.getmdl.io/1.1.3/material.grey-orange.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="/css/hmdl-style.css"/>
	<link rel="stylesheet" href="/css/pygment.css">


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-103806632-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>


    <title>GoogleCTF 2017 - Inst Prof (Part 1)</title>
</head>

<body style="background-image: url('/images/background.jpg');">
    <div id="MainCnt" class="hmdl-body mdl-layout mdl-js-layout has-drawer is-upgraded">        
        <header class="mdl-layout__header mdl-layout__header--transparent mdl-layout__header--scroll">
            <div class="mdl-layout__header-row">
                <div class="mdl-layout-spacer"></div>
                <nav class="mdl-navigation">
                <a class="mdl-navigation__link" href="/">Home</a>
                <a class="mdl-navigation__link" href="/post/">Articles</a>
                <a class="mdl-navigation__link" href="/project/">Projects</a>
                <a class="mdl-navigation__link" href="/about/">About</a>
                </nav>
            </div>
        </header>
        <div class="mdl-layout__drawer">
            <nav class="mdl-navigation">
            <a class="mdl-navigation__link" href="/">Home</a>
            <a class="mdl-navigation__link" href="/post/">Articles</a>
            <a class="mdl-navigation__link" href="/project/">Projects</a>
            <a class="mdl-navigation__link" href="/about/">About</a>
            </nav>
        </div>

        <main class="mdl-layout__content">

		

            <div class="hmdl-page mdl-grid">
                <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">
                    <div class="mdl-card__media mdl-color-text--grey-50" style=" background-color:white;">
                        <h3 style="color:orange;">GoogleCTF 2017 - Inst Prof (Part 1)</h3>
                    </div>
                    <div class="hmdl-page-meta mdl-color-text--grey-700 mdl-card__supporting-text">
                        <div class="minilogo" style="background-image: url('/images/avatar-64x64.png');"></div>

                        <div>
							<strong>
                            		<strong>Tzaoh</strong>
							</strong>
                            <span>Aug 30, 2017</span>
                        </div>
                        <div class="section-spacer"></div>
                    </div>
                    <div class="hmdl-page-content mdl-color-text--grey-700 mdl-card__supporting-text">
                        

<p><img src="/assets/GoogleCTF2017/Inst Prof/1-inst_prof_description.png" alt="inst_prof Description" /></p>

<p>In this challenge we are given a <a href="/assets/GoogleCTF2017/Inst Prof/inst_prof">binary</a> that is running remotely at <a href="inst-prof.ctfcompetition.com:1337">inst-prof.ctfcompetition.com:1337</a>.<br />
Probably the flag will be somewhere in the server.</p>

<p>We can start getting some basic information of the binary using the unix command <code>file</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="">$ file inst_prof
</span><span class="">inst_prof: ELF </span><span class="m">64</span><span class="">-bit LSB shared object, x86-64, version </span><span class="m">1</span><span class=""> </span><span class="o">(</span><span class="">SYSV</span><span class="o">)</span><span class="">, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, </span><span class="k">for</span><span class=""> GNU/Linux </span><span class="m">2</span><span class="">.6.24, BuildID</span><span class="o">[</span><span class="">sha1</span><span class="o">]=</span><span class="">61e50b540c3c8e7bcef3cb73f3ad2a10c2589089, not stripped</span></code></pre>
</div>
<p>Interesting! It is an <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a>, a binary for unix systems and it has been compiled for a 64 bits architecture. There is another interesting thing we will want to know about this architecture: <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions">the calling convention</a>. More specifically:</p>

<blockquote>
<p>The first six arguments [of a function] are passed in registers <strong>RDI</strong>, <strong>RSI</strong>, <strong>RDX</strong>, <strong>RCX</strong>, <strong>R8</strong>, and <strong>R9</strong>.<br />
the return value is stored in <strong>RAX</strong> and <strong>RDX</strong>.</p>
</blockquote>

<p>Knowing this, we can get an idea of which data is going to be sent/received to/from a certain function.<br />
All right! let&rsquo;s see what this binary does.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="">$ wget -q https://blackhoods.github.io/assets/GoogleCTF2017/Inst%20Prof/inst_prof
</span><span class="">$ chmod +x inst_prof 
</span><span class="">$ ./inst_prof 
</span><span class="">initializing prof...ready
</span><span class=""></span><span class="m">1234</span><span class="">
</span><span class="">Segmentation fault</span></code></pre>
</div>
<p>If you execute it, you will realized that there is a delay of 5 seconds between <strong>initializing prof&hellip;</strong> and <strong>ready</strong> strings. We do not want to wait 5 seconds everytime we want to test something, so lets patch it. I also used <strong>1234</strong> as input but it resulted in a segmentation fault (we will realize the reason later).</p>
<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">$ r2 -Aw inst_prof
</span><span class="">[x] Analyze all flags starting with sym. and entry0 (aa)
</span><span class="">[x] Analyze len bytes of instructions for references (aar)
</span><span class="">[x] Analyze function calls (aac)
</span><span class="">[x] Use -AA or aaaa to perform additional experimental analysis.
</span><span class="">[x] Constructing a function name for fcn.* and sym.func.* functions (aan)
</span><span class="">[0x000008c9]&gt;</span></code></pre>
</div>
<blockquote>
<p><code>-A</code> tells radare to analyze automatically the binary (so we wont need to use <code>aaa</code> inside radare).<br />
<code>-w</code> tells radare to open the binary in writable-mode to let us edit it.
Note that this time there is no <code>-d</code> (debug) flag. This is because, if especified, we will not be patching the binary itself but its memory process.
So if you want to debug it, you need to open a new r2 session.</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x000008c9]&gt; afl
</span><span class="">0x00000778    3 26           sym._init
</span><span class="">0x000007b0    2 16   -&gt; 32   sym.imp.write
</span><span class="">0x000007c0    2 16   -&gt; 48   sym.imp.mmap
</span><span class="">0x000007d0    2 16   -&gt; 48   sym.imp.alarm
</span><span class="">0x000007e0    2 16   -&gt; 48   sym.imp.read
</span><span class="">0x000007f0    2 16   -&gt; 48   sym.imp.__libc_start_main
</span><span class="">0x00000800    2 16   -&gt; 48   loc.imp.__gmon_start__
</span><span class="">0x00000810    2 16   -&gt; 48   sym.imp.munmap
</span><span class="">0x00000820    2 16   -&gt; 48   sym.imp.mprotect
</span><span class="">0x00000830    2 16   -&gt; 48   sym.imp.exit
</span><span class="">0x00000840    2 16   -&gt; 48   sym.imp.sleep
</span><span class="">0x00000850    2 16   -&gt; 48   sym.imp.__cxa_finalize
</span><span class="hl"><span class="">0x00000860    5 96   -&gt; 105  main
</span></span><span class="">0x000008c9    1 41           entry0
</span><span class="">0x000008f2    1 1            fcn.000008f2
</span><span class="">0x00000900    4 44           sym.deregister_tm_clones
</span><span class="">0x00000930    4 60           sym.register_tm_clones
</span><span class="">0x00000970    5 50           sym.__do_global_dtors_aux
</span><span class="">0x000009b0    4 53   -&gt; 46   sym.frame_dummy
</span><span class="hl"><span class="">0x000009f0    1 36           sym.alloc_page
</span></span><span class="hl"><span class="">0x00000a20    1 20           sym.make_page_executable
</span></span><span class="hl"><span class="">0x00000a40    1 15           sym.free_page
</span></span><span class="hl"><span class="">0x00000a50    3 47           sym.read_byte
</span></span><span class="hl"><span class="">0x00000a80    4 48           sym.read_n
</span></span><span class="hl"><span class="">0x00000ab0    1 15           sym.read_inst
</span></span><span class="hl"><span class="">0x00000ac0    3 153          sym.do_test
</span></span><span class="">0x00000b60    4 101          sym.__libc_csu_init
</span><span class="">0x00000bd0    1 2            sym.__libc_csu_fini
</span><span class="">0x00000bd2    1 11           fcn.00000bd2
</span><span class="">0x00000bdd    1 30           fcn.00000bdd</span></code></pre>
</div>

<blockquote>
<p><code>afl</code> command stands for &ldquo;analyze function list&rdquo;. In short, to print the functions detected by r2.</p>
</blockquote>

<p>As you will see, there is a lot of functions we need to check (at least the names give an idea of what they are used for).<br />
Lets start with the <code>main</code> function.</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x000008c9]&gt; pdf @ main
</span><span class="">            ;-- section_end..plt:
</span><span class="">            ;-- section..text:
</span><span class="">            ;-- main:
</span><span class="">â”Œ (fcn) main 105
</span><span class="">â”‚   main ();
</span><span class="">â”‚              ; DATA XREF from 0x000008e6 (entry0)
</span><span class="">â”‚           0x00000860      55             push rbp                    
</span><span class="">â”‚           0x00000861      488d357c0300.  rsi = str.initializing_prof... 
</span><span class="">â”‚           0x00000868      ba14000000     edx = 0x14                  
</span><span class="">â”‚           0x0000086d      bf01000000     edi = 1                     
</span><span class="">â”‚           0x00000872      4889e5         rbp = rsp                   
</span><span class="">â”‚           0x00000875      e836ffffff     sym.imp.write ()
</span><span class="">â”‚           0x0000087a      4883f814       var = rax - 0x14            
</span><span class="">â”‚       â”Œâ”€&lt; 0x0000087e      7407           if (!var) goto 0x887        ; unlikely
</span><span class="">â”‚       â”‚      ; JMP XREF from 0x000008b5 (main)
</span><span class="">â”‚      â”Œâ”€â”€&gt; 0x00000880      31ff           edi = 0                     
</span><span class="">â”‚      |â”‚ ; void exit(int status)
</span><span class="">â”‚      |â”‚   0x00000882      e8a9ffffff     sym.imp.exit ()             
</span><span class="">â”‚      â†‘â”‚      ; JMP XREF from 0x0000087e (main)
</span><span class="">â”‚      |â””â”€&gt; 0x00000887      bf05000000     edi = 5                     
</span><span class="">â”‚      |  ; int sleep(int s)
</span><span class="hl"><span class="">â”‚      |    0x0000088c      e8afffffff     sym.imp.sleep ()            
</span></span><span class="">â”‚      |    0x00000891      bf1e000000     edi = 0x1e                  
</span><span class="hl"><span class="">â”‚      |    0x00000896      e835ffffff     sym.imp.alarm ()
</span></span><span class="">â”‚      |    0x0000089b      488d35570300.  rsi = str.ready_n 
</span><span class="">â”‚      |    0x000008a2      ba06000000     edx = 6                     
</span><span class="">â”‚      |    0x000008a7      bf01000000     edi = 1                     
</span><span class="">â”‚      |    0x000008ac      e8fffeffff     sym.imp.write ()            
</span><span class="">â”‚      |    0x000008b1      4883f806       var = rax - 6               
</span><span class="">â”‚      â””â”€â”€&lt; 0x000008b5      75c9           if (var) goto 0x880         ; likely
</span><span class="">â””           0x000008b7      660f1f840000.                         
</span><span class="">â”‚              ; JMP XREF from 0x000008c7 (main)
</span><span class="">â”‚       â”Œâ”€&gt; 0x000008c0      31c0           eax = 0
</span><span class="">â”‚       |   0x000008c2      e8f9010000     sym.do_test ()
</span><span class="">â”‚       â””â”€&lt; 0x000008c7      ebf7           goto 0x8c0     </span></code></pre>
</div>

<blockquote>
<p><code>pdf</code> means <strong>p</strong>rint <strong>d</strong>isassemble <strong>f</strong>unction. Adding <code>@ main</code> we are telling radare which function we want to see.</p>
</blockquote>

<p>There are two functions here we want to get rid of: <code>sleep</code> which is the one we were looking for and another one which, aparently, setup an alarm. If you wait 0x1e (oops, sorry 30 seconds ðŸ˜„ ) you will see that this <code>alarm</code> function will end the process. Let&rsquo;s patch it too.</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x000008c9]&gt; wao nop @ 0x0000088c
</span><span class="">[0x000008c9]&gt; wao nop @ 0x00000896
</span><span class="">[0x000008c9]&gt; pdf @ main
</span><span class="">            ;-- section_end..plt:
</span><span class="">            ;-- section..text:
</span><span class="">            ;-- main:
</span><span class="">â”Œ (fcn) main 105
</span><span class="">â”‚   main ();
</span><span class="">â”‚              ; DATA XREF from 0x000008e6 (entry0)
</span><span class="">â”‚           0x00000860      55             push rbp                    
</span><span class="">â”‚           0x00000861      488d357c0300.  rsi = str.initializing_prof... 
</span><span class="">â”‚           0x00000868      ba14000000     edx = 0x14                  
</span><span class="">â”‚           0x0000086d      bf01000000     edi = 1                     
</span><span class="">â”‚           0x00000872      4889e5         rbp = rsp                   
</span><span class="">â”‚           0x00000875      e836ffffff     sym.imp.write ()
</span><span class="">â”‚           0x0000087a      4883f814       var = rax - 0x14            
</span><span class="">â”‚       â”Œâ”€&lt; 0x0000087e      7407           if (!var) goto 0x887        ; unlikely
</span><span class="">â”‚       â”‚      ; JMP XREF from 0x000008b5 (main)
</span><span class="">â”‚      â”Œâ”€â”€&gt; 0x00000880      31ff           edi = 0                     
</span><span class="">â”‚      |â”‚ ; void exit(int status)
</span><span class="">â”‚      |â”‚   0x00000882      e8a9ffffff     sym.imp.exit ()             
</span><span class="">â”‚      â†‘â”‚      ; JMP XREF from 0x0000087e (main)
</span><span class="">â”‚      |â””â”€&gt; 0x00000887      bf05000000     edi = 5                     
</span><span class="hl"><span class="">â”‚      |    0x0000088c      90                                         
</span></span><span class="hl"><span class="">â”‚      |    0x0000088d      90                                         
</span></span><span class="hl"><span class="">â”‚      |    0x0000088e      90                                         
</span></span><span class="hl"><span class="">â”‚      |    0x0000088f      90                                         
</span></span><span class="hl"><span class="">â”‚      |    0x00000890      90                                         
</span></span><span class="">â”‚      |    0x00000891      bf1e000000     edi = 0x1e                  
</span><span class="hl"><span class="">â”‚      |    0x00000896      90                                         
</span></span><span class="hl"><span class="">â”‚      |    0x00000897      90                                         
</span></span><span class="hl"><span class="">â”‚      |    0x00000898      90                                         
</span></span><span class="hl"><span class="">â”‚      |    0x00000899      90                                         
</span></span><span class="hl"><span class="">â”‚      |    0x0000089a      90 
</span></span><span class="">â”‚      |    0x0000089b      488d35570300.  rsi = str.ready_n 
</span><span class="">â”‚      |    0x000008a2      ba06000000     edx = 6                     
</span><span class="">â”‚      |    0x000008a7      bf01000000     edi = 1                     
</span><span class="">â”‚      |    0x000008ac      e8fffeffff     sym.imp.write ()            
</span><span class="">â”‚      |    0x000008b1      4883f806       var = rax - 6               
</span><span class="">â”‚      â””â”€â”€&lt; 0x000008b5      75c9           if (var) goto 0x880         ; likely
</span><span class="">â””           0x000008b7      660f1f840000.    
</span><span class="">â”‚              ; JMP XREF from 0x000008c7 (main)
</span><span class="">â”‚       â”Œâ”€&gt; 0x000008c0      31c0           eax = 0
</span><span class="">â”‚       |   0x000008c2      e8f9010000     sym.do_test ()
</span><span class="">â”‚       â””â”€&lt; 0x000008c7      ebf7           goto 0x8c0</span></code></pre>
</div>

<blockquote>
<p><code>wao nop</code> assembles the nop opcode (which is <code>90</code> in hexadecimal) and writes it as many times as needed to overwrite the entire destination opcode. Nop means &ldquo;<strong>N</strong>o <strong>OP</strong>eration&rdquo;.</p>
</blockquote>

<p>Once we have patched them, we could continue checking the protections of the binary. This can be done through <a href="https://raw.githubusercontent.com/slimm609/checksec.sh/master/checksec">checksec</a> script or with the r2 suite itself.</p>

<table class="hmg">
    <tr>
        <td>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="">$ checksec inst_prof 
</span><span class=""></span><span class="o">[</span><span class="">*</span><span class="o">]</span><span class=""> </span><span class="s">&#39;/root/inst_prof&#39;</span><span class="">
</span><span class="">    Arch:     amd64-64-little
</span><span class="">    RELRO:    Partial RELRO
</span><span class="">    Stack:    No canary found
</span><span class="hl"><span class="">    NX:       NX enabled
</span></span><span class="hl"><span class="">    PIE:      PIE enabled</span></span></code></pre>
</div>
        </td>
        <td>
<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x000008c9]&gt; i~true
</span><span class="">iorw     true
</span><span class="">havecode true
</span><span class="">linenum  true
</span><span class="">lsyms    true
</span><span class="hl"><span class="">nx       true
</span></span><span class="hl"><span class="">pic      true
</span></span><span class="">relocs   true
</span><span class="">va       true</span></code></pre>
</div>
        </td>
        <td>
<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">$ rabin2 -I inst_prof | grep true
</span><span class="">havecode true
</span><span class="">linenum  true
</span><span class="">lsyms    true
</span><span class="hl"><span class="">nx       true
</span></span><span class="hl"><span class="">pic      true
</span></span><span class="">relocs   true
</span><span class="">va       true</span></code></pre>
</div>
        </td>
    </tr>
</table>

<p>What matters here is the <code>NX</code> and <code>PIE</code> flags.</p>

<ol>
<li><p><code>NX</code> is telling us that there are memory sections marked as Non-eXecutable: even if we are lucky enough to insert opcodes in some part of the memory we will need that part of the memory to be marked as executable.</p></li>

<li><p><code>PIE</code> tells us that the executable will be load in a randomly aligned address, so we will not be able to use fixed memory addresses to call functions.</p></li>
</ol>

<p>Okay!
We can start analyzing the binary flow. We can now move to the last part of the <code>main</code> function, right after the patched calls.</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">â”‚              ; JMP XREF from 0x000008c7 (main)
</span><span class="">â”‚       â”Œâ”€&gt; 0x000008c0      31c0           eax = 0
</span><span class="hl"><span class="">â”‚       |   0x000008c2      e8f9010000     sym.do_test ()
</span></span><span class="">â”‚       â””â”€&lt; 0x000008c7      ebf7           goto 0x8c0</span></code></pre>
</div>

<p>Just an infinite loop to a function called <code>sym.do_test</code>. Unless there is some logic inside <code>sym.do_test</code> to end the program (like an <code>exit</code> function) it could never end!</p>

<p>Are not you curious about its content?</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x000008c9]&gt; pdf @ sym.do_test
</span><span class="">â”Œ (fcn) sym.do_test 153
</span><span class="">â”‚   sym.do_test ();
</span><span class="">â”‚           ; var int local_18h @ rbp-0x18
</span><span class="">â”‚              ; CALL XREF from 0x000008c2 (main)
</span><span class="">â”‚           0x00000ac0      55             push rbp
</span><span class="">â”‚           0x00000ac1      31c0           eax = 0
</span><span class="">â”‚           0x00000ac3      4889e5         rbp = rsp
</span><span class="">â”‚           0x00000ac6      4154           push r12
</span><span class="">â”‚           0x00000ac8      53             push rbx
</span><span class="">â”‚           0x00000ac9      4883ec10       rsp -= 0x10
</span><span class="hl"><span class="">â”‚           0x00000acd      e81effffff     sym.alloc_page ()
</span></span><span class="">â”‚           0x00000ad2      4889c3         rbx = rax
</span><span class="hl"><span class="">â”‚           0x00000ad5      488d05240100.  rax = obj.template
</span></span><span class="">â”‚           0x00000adc      488d7b05       rdi = [rbx + 5]
</span><span class="">â”‚           0x00000ae0      488b10         rdx = qword [rax]
</span><span class="">â”‚           0x00000ae3      488913         qword [rbx] = rdx
</span><span class="">â”‚           0x00000ae6      8b5008         edx = dword [rax + 8]
</span><span class="">â”‚           0x00000ae9      895308         dword [rbx + 8] = edx
</span><span class="">â”‚           0x00000aec      0fb7500c       edx = word [rax + 0xc]
</span><span class="">â”‚           0x00000af0      0fb6400e       eax = byte [rax + 0xe]
</span><span class="">â”‚           0x00000af4      6689530c       word [rbx + 0xc] = dx
</span><span class="">â”‚           0x00000af8      88430e         byte [rbx + 0xe] = al
</span><span class="">â”‚         ; ssize_t read(int fildes, void *buf, size_t nbyte)
</span><span class="hl"><span class="">â”‚           0x00000afb      e8b0ffffff     sym.read_inst ()
</span></span><span class="">â”‚           0x00000b00      4889df         rdi = rbx
</span><span class="hl"><span class="">â”‚           0x00000b03      e818ffffff     sym.make_page_executable ()
</span></span><span class="">â”‚           0x00000b08      0f31          
</span><span class="">â”‚           0x00000b0a      48c1e220       rdx &lt;&lt;&lt;= 0x20
</span><span class="">â”‚           0x00000b0e      4989c4         r12 = rax
</span><span class="">â”‚           0x00000b11      31c0           eax = 0
</span><span class="">â”‚           0x00000b13      4909d4         r12 |= rdx
</span><span class="hl"><span class="">â”‚           0x00000b16      ffd3           rbx ()
</span></span><span class="">â”‚           0x00000b18      0f31               
</span><span class="">â”‚           0x00000b1a      bf01000000     edi = 1
</span><span class="">â”‚           0x00000b1f      48c1e220       rdx &lt;&lt;&lt;= 0x20
</span><span class="">â”‚           0x00000b23      488d75e8       rsi = [local_18h]
</span><span class="">â”‚           0x00000b27      4809c2         rdx |= rax
</span><span class="">â”‚           0x00000b2a      4c29e2         rdx -= r12
</span><span class="">â”‚           0x00000b2d      488955e8       qword [local_18h] = rdx
</span><span class="">â”‚           0x00000b31      ba08000000     edx = 8
</span><span class="">â”‚           0x00000b36      e875fcffff     sym.imp.write ()
</span><span class="">â”‚           0x00000b3b      4883f808       var = rax - 8
</span><span class="">â”‚       â”Œâ”€&lt; 0x00000b3f      7511           if (var) goto 0xb52
</span><span class="">â”‚       â”‚   0x00000b41      4889df         rdi = rbx
</span><span class="">â”‚       â”‚ ; void free(void *ptr)
</span><span class="hl"><span class="">â”‚       â”‚   0x00000b44      e8f7feffff     sym.free_page ()
</span></span><span class="">â”‚       â”‚   0x00000b49      4883c410       rsp += 0x10
</span><span class="">â”‚       â”‚   0x00000b4d      5b             pop rbx
</span><span class="">â”‚       â”‚   0x00000b4e      415c           pop r12
</span><span class="">â”‚       â”‚   0x00000b50      5d             pop rbp
</span><span class="">â”‚       â”‚   0x00000b51      c3             
</span><span class="">â”‚       â”‚      ; JMP XREF from 0x00000b3f (sym.do_test)
</span><span class="">â”‚       â””â”€&gt; 0x00000b52      31ff           edi = 0
</span><span class="">â”‚         ; void exit(int status)
</span><span class="hl"><span class="">â””           0x00000b54      e8d7fcffff     sym.imp.exit ()</span></span></code></pre>
</div>

<p>Which are your first thoughts about the highlighted lines? mines are:</p>

<ol>
<li><p><code>sym.alloc_page ()</code>: We will start by this one. That name suggests that it will, somehow, reserve some memory right?</p></li>

<li><p><code>obj.template</code>: what is that? a template? of what?</p></li>

<li><p><code>sym.read_inst ()</code>: mmmh ok, it suggests that is going to read an instruction.</p></li>

<li><p><code>sym.make_page_executable ()</code>: aparently this is the one in charge of making a page executable (probably it will be used for the recently-created page).</p></li>

<li><p><code>rbx ()</code>: it calls a zone of memory whose address is stored in <code>rbx</code> register. What is most logical is to think that this address will be the address of the page which has already allocated (through <code>sym.alloc_page</code>) and marked as executable (through <code>sym.make_page_executable</code>)</p></li>

<li><p><code>sym.free_page ()</code> or <code>sym.imp.exit ()</code>: Depending on the condition <code>do_test</code> will be called again (so this flow will happen once more) or <code>exit</code> will be the chosen one, causing the process to be terminated.</p></li>
</ol>

<hr />

<p>Ok, with a single one-shot to <code>do_test</code> function we&rsquo;ve got a picture of the flow. Let&rsquo;s dig a bit more into the code to get a better understanding of how it is done.</p>

<h5 id="sym-alloc-page">sym.alloc_page</h5>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x000009f0]&gt; pdf @ sym.alloc_page 
</span><span class="">â”Œ (fcn) sym.alloc_page 36
</span><span class="">â”‚   sym.alloc_page ();
</span><span class="">â”‚       â†‘      ; CALL XREF from 0x00000acd (sym.do_test)
</span><span class="">â”‚       |   0x000009f0      55             push rbp                    
</span><span class="">â”‚       |   0x000009f1      4531c9         r9d = 0                     
</span><span class="">â”‚       |   0x000009f4      41b8ffffffff   r8d = 0xffffffff            ; -1 
</span><span class="">â”‚       |   0x000009fa      b922000000     ecx = 0x22                  ; &#39;&#34;&#39; 
</span><span class="">â”‚       |   0x000009ff      ba03000000     edx = 3                     
</span><span class="">â”‚       |   0x00000a04      be00100000     esi = 0x1000                
</span><span class="">â”‚       |   0x00000a09      4889e5         rbp = rsp                   
</span><span class="">â”‚       |   0x00000a0c      31ff           edi = 0                     
</span><span class="">â”‚       |   0x00000a0e      5d             pop rbp                     
</span><span class="hl"><span class="">â””       â””â”€&lt; 0x00000a0f      e9acfdffff     goto sym.imp.mmap           ; sym.imp.mmap</span></span></code></pre>
</div>

<p>It is calling an imported function called <code>mmap</code>. With a simple <code>man mmap</code> (or just looking at google) we can figure out which arguments it receives. The definition of the function was taken from manual.</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="">$ </span><span class="nx">man</span><span class=""> </span><span class="nx">mmap</span><span class="err">
</span><span class="err"></span><span class="nx">void</span><span class=""> *</span><span class="nx">mmap</span><span class="p">(</span><span class="nx">void</span><span class=""> *</span><span class="nx">addr</span><span class="p">,</span><span class=""> </span><span class="nx">size_t</span><span class=""> </span><span class="nx">length</span><span class="p">,</span><span class=""> </span><span class="nx">int</span><span class=""> </span><span class="nx">prot</span><span class="p">,</span><span class=""> </span><span class="nx">int</span><span class=""> </span><span class="nx">flags</span><span class="p">,</span><span class=""> </span><span class="nx">int</span><span class=""> </span><span class="nx">fd</span><span class="p">,</span><span class=""> </span><span class="nx">off_t</span><span class=""> </span><span class="nx">offset</span><span class="p">)</span><span class="">;</span></code></pre>
</div>
<p>If we apply the calling convention we mentioned at the beginning of the post we will get that the function is being called like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">rax</span><span class=""> </span><span class="p">=</span><span class=""> </span><span class="nx">mmap</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class=""> </span><span class="m">0</span><span class="nx">x1000</span><span class="p">,</span><span class=""> </span><span class="m">3</span><span class="p">,</span><span class=""> </span><span class="m">0</span><span class="nx">x22</span><span class="p">,</span><span class=""> </span><span class="m">-1</span><span class="p">,</span><span class=""> </span><span class="m">0</span><span class="p">)</span><span class="">;</span></code></pre>
</div>
<p>Basically it is:</p>

<ol>
<li><p>Creating a memory region somewhere.</p></li>

<li><p>With a size of <code>0x1000</code> bytes.</p></li>

<li><p>That memory region will have <strong>read</strong> and <strong>write</strong> permissions. This come from &ldquo;or-ing&rdquo;:<br />
<code>PROT_READ | PROT_WRITE = 0x1 | 0x2 = 0x3</code></p></li>

<li><p>The changes in memory are not visible to others processes and not are not backed by any file. Again, this explanation comes from &ldquo;or-ing&rdquo;:<br />
<code>MAP_PRIVATE |Â MAP_ANONYMOUSE = 0x20 |Â 0x2 = 0x22</code>.</p></li>
</ol>

<h5 id="obj-template">obj.template</h5>

<p>Obviously, it is allocating some space in memory to put something in there. <code>obj.template</code> has all the odds to has something to do with this. Lets see what is at that address:</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x000009f0]&gt; pd 8 @ obj.template 
</span><span class="">            ;-- template:
</span><span class="">               ; DATA XREF from 0x00000ad5 (sym.do_test)
</span><span class="hl"><span class="">            0x00000c00      b900100000     ecx = 0x1000                
</span></span><span class="">        â”Œâ”€&gt; 0x00000c05      90                                         
</span><span class="">        |   0x00000c06      90                                         
</span><span class="">        |   0x00000c07      90                                         
</span><span class="">        |   0x00000c08      90                                         
</span><span class="hl"><span class="">        |   0x00000c09      83e901         ecx -= 1                    
</span></span><span class="hl"><span class="">        â””â”€&lt; 0x00000c0c      75f7           if (var) goto 0xc05
</span></span><span class="">            0x00000c0e      c3                                         
</span><span class="">[0x000009f0]&gt; ? 0x1000
</span><span class="">4096 0x1000 010000 4K 0000:0000 4096 &#34;\x10&#34; 0001000000000000 4096.0 4096.000000f 4096.000000</span></code></pre>
</div>

<blockquote>
<p><code>pd 8 @ obj.template</code> indicates radare to print 8 asm instructions starting from <code>obj.template</code> address.</p>
</blockquote>

<p>Interesting, it is just a small loop, which is going to iterate <code>0x1000 = 4096</code> times. But thats all, because inside of the loop there is only NOPs opcodes.</p>

<p>Now that we know what is in there, we can keep going with the flow we were explaining before. Right after the <code>sym.alloc_page</code> call, there are the following instructions. I will explain line-by-line what they do.</p>
<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">â”‚           0x00000acd      e81effffff     sym.alloc_page ()
</span><span class="">â”‚           0x00000ad2      4889c3         rbx = rax
</span><span class="">â”‚ ; The address of the recently-allocated page is saved in rbx (remember that by default
</span><span class="">â”‚ ; the returned value of sym.alloc_page (and every function which follows the
</span><span class="">â”‚ ; previously commented convention) is stored in rax).
</span><span class="">â”‚           0x00000ad5      488d05240100.  rax = obj.template
</span><span class="">â”‚ ; It copies the address of the loop-template we have just described in rax.
</span><span class="">â”‚           0x00000adc      488d7b05       rdi = [rbx + 5]
</span><span class="">â”‚ ; It adds 5 to the address of rbx and saves the result in rdi. Note that rdi wont be used
</span><span class="">â”‚ ; in the following instrucctions so we can assume it could be the argument of the next
</span><span class="">â”‚ ; function. Remember it.
</span><span class="">â”‚           0x00000ae0      488b10         rdx = qword [rax]
</span><span class="">â”‚ ; the first 8 bytes (a qword) rax is pointing to are copied in rdx.
</span><span class="">â”‚ ; If you look again to obj.template you will realize that it is copying
</span><span class="">â”‚ ; its first 8 bytes:
</span><span class="">â”‚ ;     b900100000  ecx = 0x1000
</span><span class="">â”‚ ;     90          nop
</span><span class="">â”‚ ;     90          nop
</span><span class="">â”‚ ;     90          nop
</span><span class="">â”‚ ; 5 bytes which defines the first instruction: ecx = 0x1000
</span><span class="">â”‚ ; and another extra 3 bytes (3 NOPs instructions).
</span><span class="">â”‚           0x00000ae3      488913         qword [rbx] = rdx
</span><span class="">â”‚ ; After saving those 8 bytes in the rdx register, it copies them to the address 
</span><span class="">â”‚ ; rbx is pointing to (which is the beginning of the allocated page).
</span><span class="">â”‚           0x00000ae6      8b5008         edx = dword [rax + 8]
</span><span class="">â”‚ ; It copies 4 bytes (a dword) of the content of the address of rax+8.
</span><span class="">â”‚ ; These bytes are 90 83 e9 01 and form the following instructions:
</span><span class="">â”‚ ;     90          nop
</span><span class="">â”‚ ;     83e901      ecx -= 1
</span><span class="">â”‚ ; In short, it is copying the last nop instruction (there were 4) 
</span><span class="">â”‚ ; and new instruction in the edx register.
</span><span class="">â”‚           0x00000ae9      895308         dword [rbx + 8] = edx
</span><span class="">â”‚ ; And again it is saving those two instructions in memory, next to the previously ones. 
</span><span class="">â”‚           0x00000aec      0fb7500c       edx = word [rax + 0xc]
</span><span class="">â”‚           0x00000af0      0fb6400e       eax = byte [rax + 0xe]
</span><span class="">â”‚           0x00000af4      6689530c       word [rbx + 0xc] = dx
</span><span class="">â”‚           0x00000af8      88430e         byte [rbx + 0xe] = al
</span><span class="">â”‚ ; The rest instructions do the same operation but with less data: 2 bytes (a word)
</span><span class="">â”‚ ; and 1 byte respectively. Those bytes represent the last 2 instructions:
</span><span class="">â”‚ ;     75f7        if (var) goto 0x7ff2c49f0005
</span><span class="">â”‚ ;     c3          ret
</span><span class="">â”‚           0x00000afb      e8b0ffffff     sym.read_inst ()</span></code></pre>
</div>
<blockquote>
<p>If you do not trust me (yeah dont do it) you can check these explanations executing each instruction. For that you first need to open a new radare session and set some breakpoints to reach that memory zone. The fastest way to do it is using the following command.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="">$ r2 -Ad -c </span><span class="s">&#39;dcu main; db `/c mov rbx, rax`; dc; Vpp&#39;</span><span class=""> inst_prof</span></code></pre>
</div>
<p>Ok, that is a long cmd right? but you will see how much interesting it is.
First we tell r2 to analyze the binary and open it in <strong>debug</strong> mode <code>-Ad</code>.
Thats not enough for us and we ask him to execute the following commands (<code>-c</code>).</p>

<ol>
<li><code>dcu main</code> executes the process until arrive main function. When all the functions will be mapped in memory.</li>
<li><code>db `/c mov rbx, rax`</code> Once all the functions are mapped in memory, radare searches for the instruction &ldquo;mov rbx, rax&rdquo; and create a breakpoint at its address.<br /></li>
<li><code>dc; Vpp</code> executes the process again (which will cause the breakpoint to be hit) and swap radare to Visual mode with his second view rotation.
<br /></li>
</ol>

<p>Once there, you can press F8 while looking carefully the value of the registers and the memory pointed by rbx with: <code>px 10 @Â rbx</code>.</p>
</blockquote>

<p>In summary, the instructions between <code>sym.alloc_page</code> and <code>sym.read_inst</code> functions are used to copy the instructions from the <code>obj.template</code> into the allocated page. Now is the turn of <code>sym.read_inst</code> function.</p>

<h5 id="sym-read-inst">sym.read_inst</h5>

<p>Lets devour <code>sym.read_inst</code> now!
Remember the <code>rdi = [rbx + 5]</code> instruction I told you to remember before? Look where it points to.
<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x55cfea0bcacd]&gt; pd 6 @ rdi -5
</span><span class="">            ;-- rbx:
</span><span class="">            0x7f2d9bae5000      b900100000     ecx = 0x1000
</span><span class="">            ;-- rdi:
</span><span class="hl"><span class="">            0x7f2d9bae5005      90                                    
</span></span><span class="">            0x7f2d9bae5006      90                                     
</span><span class="">            0x7f2d9bae5007      90                                     
</span><span class="">            0x7f2d9bae5008      90                                     
</span><span class="">            0x7f2d9bae5009      83e901         ecx -= 1</span></code></pre>
</div></p>

<p>Its pointing to the first <code>nop</code> of the copy of <code>obj.template</code> which is in the recently-allocated page.
I bet there is where <code>read_inst ()</code> is going to store the read instruction.</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x000009f0]&gt; pdf @ sym.read_inst 
</span><span class="">â”Œ (fcn) sym.read_inst 15
</span><span class="">â”‚   sym.read_inst ();
</span><span class="">â”‚       â†‘      ; CALL XREF from 0x00000afb (sym.do_test)
</span><span class="">â”‚       |   0x00000ab0      55             push rbp                    
</span><span class="hl"><span class="">â”‚       |   0x00000ab1      be04000000     esi = 4                     
</span></span><span class="">â”‚       |   0x00000ab6      4889e5         rbp = rsp                   
</span><span class="">â”‚       |   0x00000ab9      5d             pop rbp                     
</span><span class="hl"><span class="">â””       â””â”€&lt; 0x00000aba      e9c1ffffff     goto sym.read_n             </span></span></code></pre>
</div>

<p>Aparently, <code>sym.read_inst</code> is nothing but a wrapper of <code>sym.read_n</code>. It just adds a second argument. Now we have:</p>

<ol>
<li>rdi = addr of first nop</li>
<li>rsi = 4</li>
</ol>

<p>That 4 is probably going to be the number of bytes being copied. It makes sense since there are exactly 4 nops instructions to be overwritten which occupy exactly 4 bytes in total.</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x000009f0]&gt; pdf @ sym.read_n
</span><span class="">â”Œ (fcn) sym.read_n 48
</span><span class="">â”‚   sym.read_n ();
</span><span class="">â”‚              ; JMP XREF from 0x00000aba (sym.read_inst)
</span><span class="">â”‚           0x00000a80      55             push rbp                    
</span><span class="">â”‚           0x00000a81      4885f6         var = rsi &amp; rsi             
</span><span class="">â”‚           0x00000a84      4889e5         rbp = rsp                   
</span><span class="">â”‚           0x00000a87      4154           push r12                    
</span><span class="">â”‚           0x00000a89      4c8d2437       r12 = [rdi + rsi]           
</span><span class="">â”‚           0x00000a8d      53             push rbx                    
</span><span class="">â”‚           0x00000a8e      4889fb         rbx = rdi                   
</span><span class="">â”‚       â”Œâ”€&lt; 0x00000a91      7418           if (!var) goto 0xaab
</span><span class="">â”‚       â”‚   0x00000a93      0f1f440000                                 
</span><span class="">â”‚       â”‚      ; JMP XREF from 0x00000aa9 (sym.read_n)
</span><span class="">â”‚      â”Œâ”€â”€&gt; 0x00000a98      31c0           eax = 0                     
</span><span class="">â”‚      |â”‚   0x00000a9a      4883c301       rbx += 1                    
</span><span class="hl"><span class="">â”‚      |â”‚   0x00000a9e      e8adffffff     sym.read_byte ()            
</span></span><span class="hl"><span class="">â”‚      |â”‚   0x00000aa3      8843ff         byte [rbx - 1] = al         
</span></span><span class="">â”‚      |â”‚   0x00000aa6      4c39e3         var = rbx - r12             
</span><span class="">â”‚      â””â”€â”€&lt; 0x00000aa9      75ed           if (var) goto 0xa98
</span><span class="">â”‚       â”‚      ; JMP XREF from 0x00000a91 (sym.read_n)
</span><span class="">â”‚       â””â”€&gt; 0x00000aab      5b             pop rbx                     
</span><span class="">â”‚           0x00000aac      415c           pop r12                     
</span><span class="">â”‚           0x00000aae      5d             pop rbp                     
</span><span class="">â””           0x00000aaf      c3                                         </span></code></pre>
</div>

<p>This loop seems a bit confusing, but it is just iterating 4 times (going from -3 to 0) calling <code>sym.read_byte()</code> and retrieving <code>1 byte</code> of the input string. Then it just stores it overwriting one of the previously commented <code>nop</code> opcodes.</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x000009f0]&gt; pdf @ sym.read_byte
</span><span class="">â”Œ (fcn) sym.read_byte 47
</span><span class="">â”‚   sym.read_byte ();
</span><span class="">â”‚           ; var int local_1h @ rbp-0x1
</span><span class="">â”‚              ; CALL XREF from 0x00000a9e (sym.read_n)
</span><span class="">â”‚           0x00000a50      55             push rbp                    
</span><span class="">â”‚           0x00000a51      31ff           edi = 0                     
</span><span class="">â”‚           0x00000a53      ba01000000     edx = 1                     
</span><span class="">â”‚           0x00000a58      4889e5         rbp = rsp                   
</span><span class="">â”‚           0x00000a5b      4883ec10       rsp -= 0x10                 
</span><span class="">â”‚           0x00000a5f      488d75ff       rsi = [local_1h]            
</span><span class="">â”‚           0x00000a63      c645ff00       byte [local_1h] = 0         
</span><span class="">â”‚         ; ssize_t read(int fildes, void *buf, size_t nbyte)
</span><span class="hl"><span class="">â”‚           0x00000a67      e874fdffff     sym.imp.read ()             
</span></span><span class="">â”‚           0x00000a6c      4883f801       var = rax - 1               
</span><span class="">â”‚       â”Œâ”€&lt; 0x00000a70      7506           if (var) goto 0xa78         ; likely
</span><span class="">â”‚       â”‚   0x00000a72      0fb645ff       eax = byte [local_1h]       
</span><span class="">â”‚       â”‚   0x00000a76      c9                                         
</span><span class="">â”‚       â”‚   0x00000a77      c3                                         
</span><span class="">â”‚       â”‚      ; JMP XREF from 0x00000a70 (sym.read_byte)
</span><span class="">â”‚       â””â”€&gt; 0x00000a78      31ff           edi = 0                     
</span><span class="">â”‚         ; void exit(int status) ; sym.imp.exit
</span><span class="">â””           0x00000a7a      e8b1fdffff     sym.imp.exit ()             
</span><span class="">[0x000009f0]&gt; </span></code></pre>
</div>

<p>And nothing interesting inside <code>sym.read_byte</code>, it is just another wapper to call <code>read</code> with the following fixes values:</p>

<ol>
<li><code>rdi = 0</code> which means &ldquo;read from the standard input&rdquo; (basically what the user presses in the shell).</li>
<li><code>rsi</code> is an address of a variable where <code>read</code> will store the input.</li>
<li><code>rdx = 1</code> the expected length of the input.</li>
</ol>

<p>sigh, this is being long. To check all this out we can start radare with some random input and execute the binary until the instruction right after <code>read_inst</code> call. Once there, we only need to check if the input string are there instead of the nop opdes</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">$ r2 -Ad -R &#39;stdin=&#34;AAAA&#34;&#39; -c &#39;dcu `/r sym.read_inst~[1]`; px 4 @r:rbx+5; dso; px 4 @r:rbx+5;&#39; inst_prof</span></code></pre>
</div>

<blockquote>
<p><code>-Ad</code>: Again analyze and debug it.<br />
<code>-R 'stdin=&quot;AAAA&quot;'</code>: To pass AAAA as the standard input.<br />
<code>-c</code>: To execute commands once r2 has ended loading the binary.<br />
<code>dcu `/r sym.read_inst~[1]`</code>: <code>/r sym.read_inst</code> will return all the calls to that function. From those results, we filter the address with <code>~[1]</code>. Knowing the address we can use <code>dcu address</code> which will execute the process until that address.<br />
<code>px 4 @r:rbx+5</code>: prints 4 hexadecimal values from the address of <code>rbx+5</code> which is the address where the input is going to be written.<br />
<code>dso</code>: <strong>D</strong>ebug <strong>S</strong>tep <strong>O</strong>ver. To execute the entire <code>sym.read_inst</code> flow but without going into it.<br />
<code>px 4 @r:rbx+5</code>: print the same 4 bytes again.</p>
</blockquote>

<p>This way we can check if the write has been done correctly.</p>

<h5 id="sym-make-page-executable">sym.make_page_executable</h5>

<p>As the title suggests the purpose of this function is to make a page executable. Of course, this is the page where we have copied the <code>obj.template</code> and overwritten the nop opcodes bytes (those 90 90 90 90) with our own 4 byte input.</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x000008c9]&gt; pdf @ sym.make_page_executable 
</span><span class="">â”Œ (fcn) sym.make_page_executable 20
</span><span class="">â”‚   sym.make_page_executable ();
</span><span class="">â”‚       â†‘      ; CALL XREF from 0x00000b03 (sym.do_test)
</span><span class="">â”‚       |   0x00000a20      55             push rbp                    
</span><span class="">â”‚       |   0x00000a21      ba05000000     edx = 5                     
</span><span class="">â”‚       |   0x00000a26      be00100000     esi = 0x1000                
</span><span class="">â”‚       |   0x00000a2b      4889e5         rbp = rsp                   
</span><span class="">â”‚       |   0x00000a2e      5d             pop rbp                     
</span><span class="hl"><span class="">â””       â””â”€&lt; 0x00000a2f      e9ecfdffff     goto sym.imp.mprotect</span></span></code></pre>
</div>

<p>As previously seen, the call is following the commented convention. It is using the registers <code>rdi</code> (it was set one instruction before the call to <code>sym.make_page_executable</code> in <code>0x00000ad2</code>), <code>rsi</code> and <code>rdx</code>. Three arguments. The entire call could me summarize like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">int</span><span class=""> </span><span class="nx">mprotect</span><span class="p">(</span><span class="nx">address_to_copied_template</span><span class="p">,</span><span class=""> </span><span class="m">0</span><span class="nx">x1000</span><span class="p">,</span><span class=""> </span><span class="nx">PROT_EXEC</span><span class="p">)</span><span class="">;</span></code></pre>
</div>
<p>At this point no further explanation is needed on this function, right?
It is just saying: &ldquo;Hey, please, from this address, count 0x1000 bytes and make the entire region executable&rdquo;.</p>

<p>So now our input bytes could be executed, which is the purpose of the following entry: <code>rbx()</code></p>

<h5 id="rbx">rbx ()</h5>

<p>So&hellip; (cheer up we are finishing!) <code>rbx</code> register contains the address of the first instruction of the <code>obj.template</code> duplicate. Remember that this duplicate does not contain <code>nop</code> instructions anymore but our input of 4 bytes.</p>

<p>It will <strong>execute</strong> something we provide to it!</p>

<p>We can not create a 4-byte-lengh shellcode though, but hey we will deal with it later.</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">0x7fdeaba18000 240 /root/inst_prof]&gt; ?0;f tmp;s.. @ rbx
</span><span class="">- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
</span><span class="">0x7fff40b82ac8  189b 0f42 cf55 0000 b08c 80ab de7f 0000  ...B.U..........
</span><span class="">0x7fff40b82ad8  0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="">0x7fff40b82ae8  c998 0f42 cf55 0000 002b b840 ff7f 0000  ...B.U...+.@....
</span><span class="">0x7fff40b82af8  c798 0f42 cf55 0000 609b 0f42 cf55 0000  ...B.U..`..B.U..
</span><span class=""> rax 0x00000000           rbx 0x7fdeaba18000       rcx 0x7fdeab53e497
</span><span class=""> rdx 0x8ec00000000         r8 0xffffffffffffffff    r9 0x00000000
</span><span class=""> r10 0x00000487           r11 0x00000202           r12 0x8ecf3e8e3d8
</span><span class=""> r13 0x7fff40b82be0       r14 0x00000000           r15 0x00000000
</span><span class=""> rsi 0x00001000           rdi 0x7fdeaba18000       rsp 0x7fff40b82ac8
</span><span class=""> rbp 0x7fff40b82af0       rip 0x7fdeaba18000       
</span><span class="">orax 0xffffffffffffffff
</span><span class="hl"><span class="">            ;-- rbx:
</span></span><span class="">            ;-- rdi:
</span><span class="">            ;-- rip:
</span><span class="">            0x7fdeaba18000      b900100000     ecx = 0x1000            ; rsi
</span><span class="hl"><span class="">        â”Œâ”€&gt; 0x7fdeaba18005      4141414183e9.  r9d -= 1                ; orax
</span></span><span class="">        â””â”€&lt; 0x7fdeaba1800c      75f7           if (var) goto 0x7fdeaba18005
</span><span class="">            0x7fdeaba1800e      c3             </span></code></pre>
</div>

<h5 id="sym-free-page">sym.free_page</h5>

<p>The last function is <code>sym.free_page</code> and its the one in charge of deallocating the page the process was using during its entire flow execution.</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">[0x7fc9a5eeac20]&gt; pdf @ sym.free_page 
</span><span class="">â”Œ (fcn) sym.free_page 15
</span><span class="">â”‚   sym.free_page ();
</span><span class="">â”‚       â†‘      ; CALL XREF from 0x5603de075b44 (sym.do_test)
</span><span class="">â”‚       |   0x5603de075a40      55             push rbp                
</span><span class="">â”‚       |   0x5603de075a41      be00100000     esi = 0x1000            
</span><span class="">â”‚       |   0x5603de075a46      4889e5         rbp = rsp               
</span><span class="">â”‚       |   0x5603de075a49      5d             pop rbp                 
</span><span class="hl"><span class="">â””       â””â”€&lt; 0x5603de075a4a      e9c1fdffff     goto sym.imp.munmap</span></span></code></pre>
</div>

<p>Have in mind that this step is quite important. Until this point, the process has configured a memory area with:</p>

<ol>
<li><strong>Write</strong> privileges (Do you remember those <code>PROT_READ | PROT_WRITE</code> stuff right?)</li>
<li>And <strong>execution</strong> privileges (using the <code>sym.make_page_executable</code>).</li>
</ol>

<p>It is not common to find memory regions with both privileges, because someone could use them to store unwanted stuff (like a shellcode ðŸ˜ ) and execute it.
That is the main reason why it is a good idea to deallocate the page.</p>

<div class="highlight"><pre class="chroma"><code class="language-r2" data-lang="r2"><span class="">$ r2 -Ad -R &#39;stdin=&#34;AAAA&#34;&#39; -c &#39;dcu `/r sym.make_page_executable~[1]`; dm~unk2; dso; dm~unk2;&#39; inst_prof
</span><span class="">Process with PID 11008 started...
</span><span class="">= attach 11008 11008
</span><span class="">bin.baddr 0x55e96f469000
</span><span class="">Using 0x55e96f469000
</span><span class="">Assuming filepath /root/inst_prof
</span><span class="">asm.bits 64
</span><span class="">[x] Analyze all flags starting with sym. and entry0 (aa)
</span><span class="">TODO: esil-vm not initialized
</span><span class="">[Cannot determine xref search boundariesr references (aar)
</span><span class="">[x] Analyze len bytes of instructions for references (aar)
</span><span class="">[x] Analyze function calls (aac)
</span><span class="">[x] Use -AA or aaaa to perform additional experimental analysis.
</span><span class="">[x] Constructing a function name for fcn.* and sym.func.* functions (aan)
</span><span class="">ptrace (PT_ATTACH): Operation not permitted
</span><span class="">= attach 11008 11008
</span><span class="">[0x7ff8a50b5ff0-0x7ff8a50b6000] Continue until 0x55e96f469b03 using 1 bpsize
</span><span class="">initializing prof...ready
</span><span class="">hit breakpoint at: 55e96f469b03
</span><span class="">hit breakpoint at: 55e96f469b08
</span><span class="hl"><span class="">usr    16K 0x00007ff8a52b2000 - 0x00007ff8a52b6000 s -rw- unk2 unk2
</span></span><span class="hl"><span class="">usr     4K 0x00007ff8a52b2000 - 0x00007ff8a52b3000 s -r-x unk2 unk2
</span></span><span class=""> -- Helping siol merge? No way, that would be like.. way too much not lazy. - vifino</span></code></pre>
</div>

<blockquote>
<p>The command used is pretty similar to the previous one:<br />
<code>-Ad</code>: Again analyze and debug it.<br />
<code>-R 'stdin=&quot;AAAA&quot;'</code>: To pass AAAA as the standard input.<br />
<code>-c</code>: To execute commands once r2 has ended loading the binary.<br />
<code>dcu `/r sym.make_page_executable~[1]`</code>: <code>/r sym.make_page_executable</code> will return all the calls to that function. From those results, we filter the address with <code>~[1]</code>. Knowing the address we can use <code>dcu address</code> which will execute the process until that address.<br />
<code>dm~unk2</code>: <code>dm</code> returns the mapping of the memory of the process. We are filtering the results because we already know that the interesting one has the <code>unk2</code> string.<br />
<code>dso</code>: <strong>D</strong>ebug <strong>S</strong>tep <strong>O</strong>ver. To execute the entire <code>sym.make_executable</code> flow but without going into it.<br />
<code>dm~unk2</code>: to print the map of the region we are interested at, again.</p>
</blockquote>

<p>We are printing the maps of the process before and after the call to <code>sym.make_page_executable</code>. When writting our input, the memory area has the write privilege (<code>-rw-</code>), but
after the call to <code>sym.make_page_executable</code> those permissions has been changed to <code>-r-x</code> which is perfect because otherwise the <code>rbx()</code> call would fail.</p>

<hr />

<p>Finally! we ended describing the entire flow of the program step by step.
As this article is getting very long I have decided to stop writing here and to explain the exploitation phase in part 2 (<strong>comming soon</strong>).</p>

<p>Congratz for reaching the end of the first part. Reading and understanding it must have been almost as tough as writing it. However, if something was not clear I recommend to re-read it that part again. Otherwise, you will likely get lost on the next part.</p>

<table class="hmg">
    <tr>
        <td>
            <h3>References</h3>
            <ol>
                <li><a href="https://github.com/radare/radare2">radare2</a> - To analyze the binary.</li>
                <li><a href="https://binarystud.io/googlectf-2017-inst-prof-152-final-value.html">BinaryStud.io</a> - Another solution using r2!</li>
                <li><a href="https://en.wikipedia.org/wiki/Opcode) and [Bit NX] (https://es.wikipedia.org/wiki/Bit_NX">OPCode</a></li>
                <li><a href="https://raw.githubusercontent.com/slimm609/checksec.sh/master/checksec">CheckSec</a></li>
            </ol>
        </td>
        <td>
            <h3>Some thanks</h3>
            <ol>
                <li><a href="https://github.com/trufae">@pancake</a> - For reviewing this article and pointing some improvements on it.</li>
                <li><a href="https://github.com/TobalJackson/radare2-pygments-lexer">@TobalJackson</a> - For his lexer for r2 highlighting in hugo engine.</li>
            </ol>
        </td>
    </tr>
</table>

                    </div>
                    <div class="hmdl-page-comments mdl-color-text--primary-contrast mdl-card__supporting-text comments"> 
                        <strong>
                            	<strong>Tzaoh</strong>
						</strong>
                        <p></p>
                    </div>  
                </div>                
                <nav class="mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
                    <a href="/post/garage_door/rfcommunication/">
                        <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                        <i class="icon ion-android-arrow-back"></i>
                        </button>
                        Older
                    </a>
                    <div class="section-spacer"></div>
                </nav>
 
            </div>        
        </main>
        <footer class="mdl-mini-footer">
            <div class="mdl-mini-footer--left-section">                
                <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-mini-footer--social-btn social-btn" href="mailto:Firstname@example.com?subject=Hi">
                    <i class="material-icons_lg icon ion-email"></i>
                    <span class="visuallyhidden">Email</span>
                </a>
                <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-mini-footer--social-btn social-btn" href="https://github.com/BlackHoods">
                    <i class="material-icons_lg icon ion-social-github"></i>
                    <span class="visuallyhidden">Github</span>
                </a>
                <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-mini-footer--social-btn social-btn" href="https://twitter.com/firstname_lastname">
                    <i class="material-icons_lg icon ion-social-twitter "></i>
                    <span class="visuallyhidden">Twitter</span>
                </a>


            </div>
            <div class="mdl-mini-footer--right-section">
                <span>Â© 2017 </span>
            </div>
        </footer>
        <div class="mdl-layout__obfuscator"></div>
    </div>
    <script src="https://code.getmdl.io/1.1.3/material.min.js"></script>


</body>
</html>

